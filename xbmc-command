#!/usr/bin/env python2
# -*- coding: utf-8 -*-
#
# simple XBMC command client.
#
# Copyright (C) 2013 Christoph GÃ¶ttschkes
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

import argparse

try:
  import ConfigParser as configparser
except ImportError:
  import configparser

import importlib
import inspect
import os
import socket
import sys

import xbmc_command

__prog__ = xbmc_command.core.prog
__version__ = xbmc_command.core.version

__usage__ = ""

__help__ = """
%%s
Connects to the XBMC Mediacenter at <host>:<port> via TCP
and executes the specified command.

If --host, --port or --timeout is not present and the config
file ~/.config/xbmc-command.cfg is readable, the values
specified in this file will be used.

Optional arguments:
  --host <host>     connect to server at host <host>
  --port <port>     connect to server at port <port>
  --timeout <sec>   wait <sec> till timeout, default 5
  --help            show this help message and exit
  --version         output version information and exit

Available commands are:
%%s
See '%s <command> --help' for more information
on a specific command.
""".lstrip() % (__prog__)

__version__ = "%s version %s\n" % (__prog__, __version__)

def create_help():
  global __help__
  shift = str(len('usage: ' + __prog__ + ' ') - 3)
  available_commands = ''
  for command in xbmc_command.__all__:
    available_commands += '  %-' + shift + 's %s\n'
    cmd = command_type(command)()
    available_commands = available_commands % (command, cmd.short_description)

  __help__ = __help__ % (__usage__, available_commands)

def main(host, port, timeout, command, args):
  command = command()

  xbmc = xbmc_command.core.XBMC(host, port)
  xbmc.settimeout(timeout)
  command.xbmc = xbmc

  args = command.parse_args(args)

  try:
    xbmc.connect()
  except socket.timeout:
    sys.exit("Unable to connect to host %s:%s" % (host, port))

  try:
    command.call(args)
  except xbmc_command.core.CommandException as e:
    sys.exit(e.msg)
  finally:
    xbmc.close()

def command_type(command):
  try:
    cmd= command.replace('-', '_')
    return importlib.import_module('xbmc_command.%s' % cmd).Command
  except:
    raise argparse.ArgumentTypeError("command '%s' not found" % command)

class ConfigParser(configparser.SafeConfigParser, object):

  def get(self, section, option):
    if not self.has_section(section) or not self.has_option(section, option):
      return None
    return super(ConfigParser, self).get(section, option)

def print_help():
  create_help()
  sys.stdout.write(__help__)
  sys.exit(0)

def exit_usage(parser, msg):
  parser.print_usage()
  sys.exit(msg)

if __name__ == '__main__':
  configp = ConfigParser()
  configp.read(os.path.expanduser("~/.config/xbmc-command.cfg"))

  parser = argparse.ArgumentParser(prog=__prog__, add_help=False)

  parser.add_argument('--host', metavar='<host>',
      default=configp.get('XBMC', 'host'))

  parser.add_argument('--port', metavar='<port>',
      default=configp.get('XBMC', 'port'))

  parser.add_argument('--timeout', metavar='<sec>',
      default=configp.get('XBMC', 'timeout'))

  parser.add_argument('--help', action='help')
  parser.print_help = print_help

  parser.add_argument('--version', action='version')
  parser.version = __version__

  parser.add_argument('command', metavar='<command>', type=command_type)

  parser.add_argument('args', metavar='<args>', nargs=argparse.REMAINDER)

  __usage__ = parser.format_usage()

  args = parser.parse_args()

  if not args.timeout:
    args.timeout = 5

  port_error = "%s: error: invalid int value: '<port>': '%s'" % \
      (__prog__, args.port)
  try:
    args.port = int(args.port)
    if args.port < 0 or args.port > 65535:
      exit_usage(parser, port_error)
  except ValueError:
    exit_usage(parser, port_error)

  timeout_error = "%s: error: invalid int value --timeout: '%s'" % \
      (__prog__, args.timeout)
  try:
    args.timeout = int(args.timeout)
    if args.timeout < 0:
      exit_usage(parser, timeout_error)
  except ValueError:
    exit_usage(parser, timeout_error)

  try:
    main(args.host, args.port, args.timeout, args.command, args.args)
  except KeyboardInterrupt:
    sys.stdout.write('\n')

# vim: ft=python ts=2 sts=2 sw=2 et:
